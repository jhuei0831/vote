// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package graph

import (
	"bytes"
	"context"
	"errors"
	"sync/atomic"
	"vote/app/model"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	"github.com/google/uuid"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Candidate() CandidateResolver
	Mutation() MutationResolver
	Query() QueryResolver
	Vote() VoteResolver
}

type DirectiveRoot struct {
	WithCandidates func(ctx context.Context, obj any, next graphql.Resolver, withCandidates bool) (res any, err error)
}

type ComplexityRoot struct {
	Candidate struct {
		CreatedAt  func(childComplexity int) int
		ID         func(childComplexity int) int
		Name       func(childComplexity int) int
		QuestionID func(childComplexity int) int
		Result     func(childComplexity int) int
		UpdatedAt  func(childComplexity int) int
	}

	Mutation struct {
		CreateQuestion func(childComplexity int, input model.QuestionCreate) int
		CreateUser     func(childComplexity int, input model.UserCreate) int
		CreateVote     func(childComplexity int, input model.VoteCreate) int
		DeleteVote     func(childComplexity int, uuids []uuid.UUID) int
		UpdateVote     func(childComplexity int, uuid uuid.UUID, input model.VoteUpdate) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Query struct {
		Questions func(childComplexity int, input *model.QuestionQuery, withCandidates bool) int
		Users     func(childComplexity int) int
		Votes     func(childComplexity int, input *model.VoteQuery, withQuestions bool) int
	}

	Question struct {
		Candidates  func(childComplexity int) int
		CreatedAt   func(childComplexity int) int
		Description func(childComplexity int) int
		ID          func(childComplexity int) int
		Title       func(childComplexity int) int
		UpdatedAt   func(childComplexity int) int
		VoteID      func(childComplexity int) int
	}

	QuestionConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	QuestionEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}

	User struct {
		Account func(childComplexity int) int
		Email   func(childComplexity int) int
		ID      func(childComplexity int) int
	}

	Vote struct {
		Creator     func(childComplexity int) int
		Description func(childComplexity int) int
		EndTime     func(childComplexity int) int
		ID          func(childComplexity int) int
		Questions   func(childComplexity int) int
		StartTime   func(childComplexity int) int
		Status      func(childComplexity int) int
		Title       func(childComplexity int) int
		Uuid        func(childComplexity int) int
	}

	VoteConnection struct {
		Edges      func(childComplexity int) int
		PageInfo   func(childComplexity int) int
		TotalCount func(childComplexity int) int
	}

	VoteEdge struct {
		Cursor func(childComplexity int) int
		Node   func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Candidate.createdAt":
		if e.complexity.Candidate.CreatedAt == nil {
			break
		}

		return e.complexity.Candidate.CreatedAt(childComplexity), true

	case "Candidate.id":
		if e.complexity.Candidate.ID == nil {
			break
		}

		return e.complexity.Candidate.ID(childComplexity), true

	case "Candidate.Name":
		if e.complexity.Candidate.Name == nil {
			break
		}

		return e.complexity.Candidate.Name(childComplexity), true

	case "Candidate.questionId":
		if e.complexity.Candidate.QuestionID == nil {
			break
		}

		return e.complexity.Candidate.QuestionID(childComplexity), true

	case "Candidate.Result":
		if e.complexity.Candidate.Result == nil {
			break
		}

		return e.complexity.Candidate.Result(childComplexity), true

	case "Candidate.updatedAt":
		if e.complexity.Candidate.UpdatedAt == nil {
			break
		}

		return e.complexity.Candidate.UpdatedAt(childComplexity), true

	case "Mutation.createQuestion":
		if e.complexity.Mutation.CreateQuestion == nil {
			break
		}

		args, err := ec.field_Mutation_createQuestion_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateQuestion(childComplexity, args["input"].(model.QuestionCreate)), true

	case "Mutation.createUser":
		if e.complexity.Mutation.CreateUser == nil {
			break
		}

		args, err := ec.field_Mutation_createUser_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateUser(childComplexity, args["input"].(model.UserCreate)), true

	case "Mutation.createVote":
		if e.complexity.Mutation.CreateVote == nil {
			break
		}

		args, err := ec.field_Mutation_createVote_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateVote(childComplexity, args["input"].(model.VoteCreate)), true

	case "Mutation.deleteVote":
		if e.complexity.Mutation.DeleteVote == nil {
			break
		}

		args, err := ec.field_Mutation_deleteVote_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteVote(childComplexity, args["uuids"].([]uuid.UUID)), true

	case "Mutation.updateVote":
		if e.complexity.Mutation.UpdateVote == nil {
			break
		}

		args, err := ec.field_Mutation_updateVote_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdateVote(childComplexity, args["uuid"].(uuid.UUID), args["input"].(model.VoteUpdate)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Query.questions":
		if e.complexity.Query.Questions == nil {
			break
		}

		args, err := ec.field_Query_questions_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Questions(childComplexity, args["input"].(*model.QuestionQuery), args["withCandidates"].(bool)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		return e.complexity.Query.Users(childComplexity), true

	case "Query.votes":
		if e.complexity.Query.Votes == nil {
			break
		}

		args, err := ec.field_Query_votes_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Votes(childComplexity, args["input"].(*model.VoteQuery), args["withQuestions"].(bool)), true

	case "Question.candidates":
		if e.complexity.Question.Candidates == nil {
			break
		}

		return e.complexity.Question.Candidates(childComplexity), true

	case "Question.createdAt":
		if e.complexity.Question.CreatedAt == nil {
			break
		}

		return e.complexity.Question.CreatedAt(childComplexity), true

	case "Question.description":
		if e.complexity.Question.Description == nil {
			break
		}

		return e.complexity.Question.Description(childComplexity), true

	case "Question.id":
		if e.complexity.Question.ID == nil {
			break
		}

		return e.complexity.Question.ID(childComplexity), true

	case "Question.title":
		if e.complexity.Question.Title == nil {
			break
		}

		return e.complexity.Question.Title(childComplexity), true

	case "Question.updatedAt":
		if e.complexity.Question.UpdatedAt == nil {
			break
		}

		return e.complexity.Question.UpdatedAt(childComplexity), true

	case "Question.voteId":
		if e.complexity.Question.VoteID == nil {
			break
		}

		return e.complexity.Question.VoteID(childComplexity), true

	case "QuestionConnection.edges":
		if e.complexity.QuestionConnection.Edges == nil {
			break
		}

		return e.complexity.QuestionConnection.Edges(childComplexity), true

	case "QuestionConnection.pageInfo":
		if e.complexity.QuestionConnection.PageInfo == nil {
			break
		}

		return e.complexity.QuestionConnection.PageInfo(childComplexity), true

	case "QuestionConnection.totalCount":
		if e.complexity.QuestionConnection.TotalCount == nil {
			break
		}

		return e.complexity.QuestionConnection.TotalCount(childComplexity), true

	case "QuestionEdge.cursor":
		if e.complexity.QuestionEdge.Cursor == nil {
			break
		}

		return e.complexity.QuestionEdge.Cursor(childComplexity), true

	case "QuestionEdge.node":
		if e.complexity.QuestionEdge.Node == nil {
			break
		}

		return e.complexity.QuestionEdge.Node(childComplexity), true

	case "User.account":
		if e.complexity.User.Account == nil {
			break
		}

		return e.complexity.User.Account(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "Vote.creator":
		if e.complexity.Vote.Creator == nil {
			break
		}

		return e.complexity.Vote.Creator(childComplexity), true

	case "Vote.description":
		if e.complexity.Vote.Description == nil {
			break
		}

		return e.complexity.Vote.Description(childComplexity), true

	case "Vote.endTime":
		if e.complexity.Vote.EndTime == nil {
			break
		}

		return e.complexity.Vote.EndTime(childComplexity), true

	case "Vote.id":
		if e.complexity.Vote.ID == nil {
			break
		}

		return e.complexity.Vote.ID(childComplexity), true

	case "Vote.questions":
		if e.complexity.Vote.Questions == nil {
			break
		}

		return e.complexity.Vote.Questions(childComplexity), true

	case "Vote.startTime":
		if e.complexity.Vote.StartTime == nil {
			break
		}

		return e.complexity.Vote.StartTime(childComplexity), true

	case "Vote.status":
		if e.complexity.Vote.Status == nil {
			break
		}

		return e.complexity.Vote.Status(childComplexity), true

	case "Vote.title":
		if e.complexity.Vote.Title == nil {
			break
		}

		return e.complexity.Vote.Title(childComplexity), true

	case "Vote.uuid":
		if e.complexity.Vote.Uuid == nil {
			break
		}

		return e.complexity.Vote.Uuid(childComplexity), true

	case "VoteConnection.edges":
		if e.complexity.VoteConnection.Edges == nil {
			break
		}

		return e.complexity.VoteConnection.Edges(childComplexity), true

	case "VoteConnection.pageInfo":
		if e.complexity.VoteConnection.PageInfo == nil {
			break
		}

		return e.complexity.VoteConnection.PageInfo(childComplexity), true

	case "VoteConnection.totalCount":
		if e.complexity.VoteConnection.TotalCount == nil {
			break
		}

		return e.complexity.VoteConnection.TotalCount(childComplexity), true

	case "VoteEdge.cursor":
		if e.complexity.VoteEdge.Cursor == nil {
			break
		}

		return e.complexity.VoteEdge.Cursor(childComplexity), true

	case "VoteEdge.node":
		if e.complexity.VoteEdge.Node == nil {
			break
		}

		return e.complexity.VoteEdge.Node(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputQuestionCreate,
		ec.unmarshalInputQuestionQuery,
		ec.unmarshalInputUserCreate,
		ec.unmarshalInputVoteCreate,
		ec.unmarshalInputVoteQuery,
		ec.unmarshalInputVoteUpdate,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../candidate.graphqls", Input: `type Candidate {
  id: ID!
  questionId: UUID!
  Name: String!
  Result: String!
  createdAt: Time!
  updatedAt: Time!
}`, BuiltIn: false},
	{Name: "../global.graphqls", Input: `scalar Time
scalar UUID
scalar Int64

"""
Pagination information for paginated results.
"""
type PageInfo {
  startCursor: String
  endCursor: String
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
}

interface pageQuery {
  first: Int64
  after: String
  last: Int64
  before: String
}`, BuiltIn: false},
	{Name: "../question.graphqls", Input: `directive @withCandidates(withCandidates: Boolean!) on FIELD_DEFINITION

type Question {
  id: ID!
  voteId: UUID!
  title: String!
  description: String!
  createdAt: Time!
  updatedAt: Time!
  candidates: [Candidate!]!
}

type QuestionConnection {
  edges: [QuestionEdge!]!
  pageInfo: PageInfo!
  totalCount: Int64!
}

type QuestionEdge {
  node: Question!
  cursor: ID!
}

input QuestionCreate {
  voteId: UUID!
  title: String!
  description: String!
}

input QuestionQuery {
  voteId: UUID
  title: String
  first: Int64
  after: String
  last: Int64
  before: String
}

extend type Query {
  questions(input: QuestionQuery, withCandidates: Boolean!): [QuestionConnection!]!
}

extend type Mutation {
  createQuestion(input: QuestionCreate!): Question!
}`, BuiltIn: false},
	{Name: "../user.graphqls", Input: `type User {
  id: ID!
  account: String!
  email: String!
}

input UserCreate {
  account: String!
  password: String!
  email: String!
}

type Query {
  users: [User!]!
}

type Mutation {
  createUser(input: UserCreate!): User!
}`, BuiltIn: false},
	{Name: "../vote.graphqls", Input: `type Vote {
  id: ID!
  uuid: UUID!
  title: String!
  description: String!
  startTime: Time!
  endTime: Time!
  creator: User!
  status: Int64!
  questions: [Question!]!
}

type VoteConnection {
  edges: [VoteEdge!]!
  pageInfo: PageInfo!
  totalCount: Int64!
}

type VoteEdge {
  node: Vote!
  cursor: ID!
}

"""
Input for creating a vote.
All time fields must be in RFC3339/ISO8601 format (e.g., "2025-11-06T12:00:00Z")
"""
input VoteCreate {
  title: String!
  description: String
  startTime: Time!
  endTime: Time!
}

input VoteUpdate {
  title: String
  description: String
  startTime: Time
  endTime: Time
  UpdatedAt: Time
}

input VoteQuery {
  id: ID
  uuid: UUID
  title: String
  startTime: Time
  endTime: Time
  first: Int64
  after: String
  last: Int64
  before: String
}

extend type Query {
  votes(input: VoteQuery, withQuestions: Boolean!): [VoteConnection!]!
}

extend type Mutation {
  createVote(input: VoteCreate!): Vote!
  updateVote(uuid: UUID!, input: VoteUpdate!): Vote!
  deleteVote(uuids: [UUID!]!): [Vote!]!
}`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
